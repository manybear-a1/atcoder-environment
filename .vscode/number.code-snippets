{
  "factorial": {
    "description": "calculate factorial of N",
    "prefix": "factorial",
    "body": [
      "//calculate factorial of N",
      "ll factorial(ll n)",
      "{",
      "  ll ans = 1;",
      "  for (ll i = 1; i <= n; i++)",
      "  {",
      "    ans *= i;",
      "    // ans %= 1000000007;",
      "  }",
      "  return ans;",
      "}"
    ],
    "scope": "cpp"
  },
  "combination": {
    "description": "calculate combination of N and K",
    "prefix": "combination",
    //ref:https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#5-%E4%BA%8C%E9%A0%85%E4%BF%82%E6%95%B0-ncr
    //ref2:https://drken1215.hatenablog.com/entry/2018/06/08/210000
    "body": [
      "//前処理はO(N)、毎回の二項係数計算はO(1)でできます。",
      "//nとkの最大値",

      "const ll MAX = ${1:510000};",
      "const ll MOD = ${2|998244353,1000000007|};",
      "",
      "ll fac[MAX], finv[MAX], inv[MAX];",
      "bool is_init = false;",
      "",
      "// テーブルを作る前処理",
      "void COMinit() {",
      "  fac[0] = fac[1] = 1;",
      "  finv[0] = finv[1] = 1;",
      "  inv[1] = 1;",
      "  for (ll i = 2; i < MAX; i++){",
      "    fac[i] = fac[i - 1] * i % MOD;",
      "    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
      "    finv[i] = finv[i - 1] * inv[i] % MOD;",
      "  }",
      "  is_init = true;",
      "}",
      "",
      "/*",
      "二項係数計算",
      "使い方",
      "```",
      "ll main() {",
      "  // 前処理",
      "  COMinit();",
      "",
      "  // 計算例",
      "  cout << COM(100000, 50000) << endl;",
      "}",
      "```",
      "*/",
      "ll COM(ll n, ll k){",
      "  if (!is_init)",
      "  {",
      "    // cout << \"COMinit()をしてください\" << endl;",
      "    // assert(false);",
      "    // return -1;",
      "    COMinit();",
      "  }",
      "  if (n > MAX || k > MAX)",
      "  {",
      "    //エンコードをutf-8 with BOMにしてください",
      "    cout << \"n,kは\" << MAX << \"以下である必要があります\" << endl;",
      "    assert(false);",
      "    return 0;",
      "  }",
      "  if (n < k) return 0;",
      "  if (n < 0 || k < 0) return 0;",
      "  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
      "}",
      "",
    ]
  },
  "GCD": {
    "description": "calculate GCD of a and b(deprecated-use gcd() in C++17)",

    "prefix": "GCD",
    "body": [
      "gcd(a,b) // C++17以降はこれを使う"
      // "//calculate GCD of a and b",
      // "template <typename T>",
      // "T gcd(T a, T b)",
      // "{",
      // "  if (b == 0)",
      // "    return a;",
      // "  else",
      // "    return gcd(b, a % b);",
      // "}"
    ],
    "scope": "cpp"
  },
  "LCM": {
    "description": "calculate LCM of a and b(deprecated-use lcm() in C++17)",
    "prefix": "LCM",
    "body": [
      // "//calculate GCD of a and b",
      // "template <typename T>",
      // "T gcd(T a, T b)",
      // "{",
      // "  if (b == 0)",
      // "    return a;",
      // "  else",
      // "    return gcd(b, a % b);",
      // "}",
      // "//calculate LCM of a and b",
      // "template <typename T>",
      // "inline T lcm(T a, T b) { return (a * b) / gcd(a, b); }"
      "lcm(a,b) // C++17以降はこれを使う"
    ],
    "scope": "cpp"
  },
  "extgcd": {
    "description": "extended Euclidean algorithm",
    "prefix": "extgcd",
    "body": [
      "/* 拡張ユークリッドの互除法の実装例",
      " 拡張ユークリッドの互除法とは、整数の組 (a,b) を入力として与えたときに以下の手順によってax+by=±gcd(a,b) となる整数の組 (x,y) を O(logmin(∣a∣,∣b∣)) で計算するアルゴリズムです。(ここで整数の組 x,y は max(∣x∣,∣y∣)≤max(∣a∣,∣b∣) を満たす整数であることが保証されています。)",
      "  ref:https://atcoder.jp/contests/abc340/editorial/9250",
      "*/",
      "P extgcd(ll a, ll b) {",
      "  if (b == 0) return make_pair(1, 0);",
      "  ll x, y;",
      "  tie(y, x) = extgcd(b, a % b);",
      "  y -= a / b * x;",
      "  return make_pair(x, y);",
      "}"

    ]
  },
  "Sieve of eratosthenes": {
    "description": "Sieve of eratosthenes(区間篩)",
    "prefix": "Sieve of eratosthenes",
    "body": [
      "// 抽象化区間篩。(extends from https://qiita.com/rsk0315_h4x/items/ff3b542a4468679fb409) 別に[1, R)でも使いまわせる",
      "// verify:https://atcoder.jp/contests/abc412/submissions/67500976",
      "// verify:https://atcoder.jp/contests/abc227/submissions/67500929",
      "class smart_sieve",
      "{",
      "  //[L, R)の範囲を篩う",
      "  // 半開区間です。",
      "  ll L, R, M;",
      "  vc<ll> small; // 小さい篩",
      "  vc<ll> aux;   // aux[i] := large[i] の素因数の積",
      "  // この部分を変更する",
      "  // テンプレ：素因数分解してその結果をそのまま保存。実際に使うと配列保存の定数倍でTLEすることが多いので、ランテスをする際に使うとよい。",
      "  // 素因数をランレングス圧縮して保存する(素因数の値,個数)。",
      "  using Data = vc<pair<ll, ll>>;",
      "  vc<Data> large; // 大きい篩",
      "  // 初期化,L,R,M,small,auxはすでに設定されている。",
      "  void init()",
      "  {",
      "    large.resize(R - L);",
      "  }",
      "  // データ取得用",
      "public:",
      "  Data factor(ll n)",
      "  {",
      "    assert(L <= n && n < R);",
      "    Data res = large[n - L];",
      "    return res;",
      "  }",
      "  // idx:L <= i < Rの時Lからのオフセットを持つ(idx = i - L)",
      "  // divisor: 素因数。小さい順に呼ばれることが保証される。",
      "  // prod: aux[idx]の値(それまでの素因数の積)。(idx + L)/prodが現在素因数分解されていない数",
      "  void divide(ll idx, ll divisor, ll prod)",
      "  {",
      "",
      "    if (!large[idx].empty() && large[idx].back().first == divisor)",
      "    {",
      "      // 既存の素因数の個数を増やす",
      "      large[idx].back().second++;",
      "    }",
      "    else",
      "    {",
      "      // 新しい素因数を追加する",
      "      large[idx].emplace_back(divisor, 1);",
      "    }",
      "  }",
      "  // ここまで",
      "",
      "public:",
      "  smart_sieve(ll L_, ll R_) : L(L_), R(R_), M(sqrt(R_) + 1)",
      "  {",
      "    assert(L <= R);",
      "    assert(L >= 1);",
      "    small.resize(M);",
      "    std::iota(small.begin(), small.end(), 0);",
      "",
      "    aux.assign(R - L, 1);",
      "    init();",
      "",
      "    for (ll i = 2; i * i < R; ++i)",
      "    {",
      "      if (small[i] < i)",
      "        continue;",
      "      small[i] = i;",
      "      for (ll j = i * i; j < M; j += i)",
      "        if (small[j] == j)",
      "          small[j] = i;",
      "",
      "      for (ll j = (L + i - 1) / i * i; j < R; j += i)",
      "      {",
      "        ll k = j;",
      "        do",
      "        {",
      "          divide(j - L, i, aux[j - L]);",
      "          aux[j - L] *= i;",
      "          k /= i;",
      "        } while (k % i == 0);",
      "      }",
      "    }",
      "    rep(i, R - L)",
      "    {",
      "      ll n = L + i;",
      "      if (n / aux[n - L] > 1)",
      "      {",
      "        divide(n - L, n / aux[n - L], aux[n - L]);",
      "        aux[n - L] *= n / aux[n - L];",
      "      }",
      "    }",
      "  }",
      "};",
    ]
  },
  "mint": {
    "description": "mint",
    "prefix": "mint",
    "body": [
      //ref:https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#1-%E3%81%AA%E3%81%9C-998244353-%E3%81%A7%E5%89%B2%E3%82%8B%E3%81%AE%E3%81%8B
      "// modint: mod 計算を int を扱うように扱える構造体",
      "template<ll MOD> struct Fp {",
      "  ll val;",
      "  constexpr Fp(ll v = 0) noexcept : val(v % MOD) {",
      "      if (val < 0) val += MOD;",
      "  }",
      "  constexpr ll getmod() { return MOD; }",
      "  constexpr Fp operator - () const noexcept {",
      "      return val ? MOD - val : 0;",
      "  }",
      "  constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }",
      "  constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }",
      "  constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }",
      "  constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }",
      "  constexpr Fp& operator += (const Fp& r) noexcept {",
      "      val += r.val;",
      "      if (val >= MOD) val -= MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator -= (const Fp& r) noexcept {",
      "      val -= r.val;",
      "      if (val < 0) val += MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator *= (const Fp& r) noexcept {",
      "      val = val * r.val % MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator /= (const Fp& r) noexcept {",
      "      ll a = r.val, b = MOD, u = 1, v = 0;",
      "      while (b) {",
      "          ll t = a / b;",
      "          a -= t * b; swap(a, b);",
      "          u -= t * v; swap(u, v);",
      "      }",
      "      val = val * u % MOD;",
      "      if (val < 0) val += MOD;",
      "      return *this;",
      "  }",
      "  constexpr bool operator == (const Fp& r) const noexcept {",
      "      return this->val == r.val;",
      "  }",
      "  constexpr bool operator != (const Fp& r) const noexcept {",
      "      return this->val != r.val;",
      "  }",
      "  friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept",
      "  {",
      "    ll t;",
      "    is >> t;",
      "    x = Fp<MOD>(t);",
      "    return is;",
      "  }",
      "  friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {",
      "      return os << x.val;",
      "  }",
      "  friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, ll n) noexcept {",
      "      if (n == 0) return 1;",
      "      auto t = modpow(a, n / 2);",
      "      t = t * t;",
      "      if (n & 1) t = t * a;",
      "      return t;",
      "  }",
      "};",
      "",
      "",
      "const ll MOD = ${1|998244353,1000000007|};",
      "using mint = Fp<MOD>;",
    ]
  },
  "isPrime": {
    "prefix": "isPrime",
    "description": "is Prime",
    "body": [
      "bool isPrime(ll x){",
      "ll i;",
      "  if(x < 2) return 0;",
      "  else if(x == 2) return 1;",
      "  if(x%2 == 0) return 0;",
      "  for( i = 3; i * i <= x; i += 2) if(x%i == 0) return 0;",
      "  return 1;",
      "}"
    ]
  },
  "primeFactorization": {
    "prefix": "primeFactorization",
    "description": "prime Factorization",
    "body": [
      "vector<pair<ll, ll>> primeFactorization(ll n){",
      "  vector<pair<ll, ll>> res;",
      "  for(ll i = 2; i * i <= n; i++){",
      "    if(n % i != 0) continue;",
      "    res.push_back({i, 0});",
      "    while(n % i == 0){",
      "      n /= i;",
      "      res.back().second++;",
      "    }",
      "  }",
      "  if(n != 1) res.push_back({n, 1});",
      "  return res;",
      "}"
    ]
  },
  "digitsum": {
    "prefix": "digitsum",
    "description": "sum of digits",
    "body": [
      "ll digsum(ll n) {",
      "  ll res = 0;",
      "  while(n > 0) {",
      "      res += n % 10;",
      "      n /= 10;",
      "  }",
      "  return res;",
      "}"
    ]
  },
  "digits": {
    "prefix": "digits",
    "description": "digits",
    "body": [
      "ll digits(ll n) {",
      "  ll res = 0;",
      "  while(n > 0) {",
      "      res++;",
      "      n /= 10;",
      "  }",
      "  return res;",
      "}"
    ]
  },
  "enumDiv": {
    "prefix": "enumDiv",
    "description": "enum of divisors",
    "body": [
      "vector<ll> enum_div(ll n){",
      "  vector<ll> ret;",
      "  for(ll i = 1 ; i * i <= n ; ++i){",
      "    if(n%i == 0){",
      "      ret.push_back(i);",
      "      if(i != 1 && i * i != n){",
      "        ret.push_back(n/i);",
      "      }",

      "    }",
      "  }",
      "  return ret;",
      "}"
    ]
  },
  "Radix Conversion": {
    "description": "Radix Conversion(2-10進数の数値の文字列を処理する)",
    "prefix": "Radix Conversion",
    "body": [
      "// 2-10進数の数値の文字列を処理する(16進非対応)",
      "string encode_radix(ll val, ll radix)",
      "{",
      "  string res;",
      "  while (val > 0)",
      "  {",
      "    res += (char)('0' + val % radix);",
      "    val /= radix;",
      "  }",
      "  reverse(res.begin(), res.end());",
      "  return res;",
      "}",
      "ll decode_radix(const string &s, ll radix)",
      "{",
      "  ll res = 0;",
      "  for (char c : s)",
      "  {",
      "    res *= radix;",
      "    res += c - '0';",
      "  }",
      "  return res;",
      "}",
    ]
  },
  "isqrt": {
    "description": "integer square root",
    "prefix": "isqrt",
    "body": [
      "// sample: https://atcoder.jp/contests/abc230/submissions/67802776",
      "ll isqrt(ll x)",
      "{",
      "  ll l = 0, r = 1e9 + 1;",
      "  while (r - l > 1)",
      "  {",
      "    ll m = (l + r) / 2;",
      "    if (m * m <= x)",
      "    {",
      "      l = m;",
      "    }",
      "    else",
      "    {",
      "      r = m;",
      "    }",
      "  }",
      "  return l;",
      "}",
    ]
  }
}