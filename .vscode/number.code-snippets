{
  "factorial": {
    "description": "calculate factorial of N",
    "prefix": "factorial",
    "body": [
      "//calculate factorial of N",
      "ll factorial(ll n)",
      "{",
      "  ll ans = 1;",
      "  for (ll i = 1; i <= n; i++)",
      "  {",
      "    ans *= i;",
      "    // ans %= 1000000007;",
      "  }",
      "  return ans;",
      "}"
    ],
    "scope": "cpp"
  },
  "combination": {
    "description": "calculate combination of N and K",
    "prefix": "combination",
    //ref:https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#5-%E4%BA%8C%E9%A0%85%E4%BF%82%E6%95%B0-ncr
    //ref2:https://drken1215.hatenablog.com/entry/2018/06/08/210000
    "body": [
      "//前処理はO(N)、毎回の二項係数計算はO(1)でできます。",
      "//nとkの最大値",

      "const ll MAX = ${1:510000};",
      "const ll MOD = ${2|998244353,1000000007|};",
      "",
      "ll fac[MAX], finv[MAX], inv[MAX];",
      "bool is_init = false;",
      "",
      "// テーブルを作る前処理",
      "void COMinit() {",
      "  fac[0] = fac[1] = 1;",
      "  finv[0] = finv[1] = 1;",
      "  inv[1] = 1;",
      "  for (ll i = 2; i < MAX; i++){",
      "    fac[i] = fac[i - 1] * i % MOD;",
      "    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
      "    finv[i] = finv[i - 1] * inv[i] % MOD;",
      "  }",
      "  is_init = true;",
      "}",
      "",
      "/*",
      "二項係数計算",
      "使い方",
      "```",
      "ll main() {",
      "  // 前処理",
      "  COMinit();",
      "",
      "  // 計算例",
      "  cout << COM(100000, 50000) << endl;",
      "}",
      "```",
      "*/",
      "ll COM(ll n, ll k){",
      "  if (!is_init)",
      "  {",
      "    // cout << \"COMinit()をしてください\" << endl;",
      "    // assert(false);",
      "    // return -1;",
      "    COMinit();",
      "  }",
      "  if (n > MAX || k > MAX)",
      "  {",
      "    //エンコードをutf-8 with BOMにしてください",
      "    cout << \"n,kは\" << MAX << \"以下である必要があります\" << endl;",
      "    assert(false);",
      "    return 0;",
      "  }",
      "  if (n < k) return 0;",
      "  if (n < 0 || k < 0) return 0;",
      "  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
      "}",
      "",
    ]
  },
  "GCD": {
    "description": "calculate GCD of a and b(deprecated-use gcd() in C++17)",

    "prefix": "GCD",
    "body": [
      "gcd(a,b) // C++17以降はこれを使う"
      // "//calculate GCD of a and b",
      // "template <typename T>",
      // "T gcd(T a, T b)",
      // "{",
      // "  if (b == 0)",
      // "    return a;",
      // "  else",
      // "    return gcd(b, a % b);",
      // "}"
    ],
    "scope": "cpp"
  },
  "LCM": {
    "description": "calculate LCM of a and b(deprecated-use lcm() in C++17)",
    "prefix": "LCM",
    "body": [
      // "//calculate GCD of a and b",
      // "template <typename T>",
      // "T gcd(T a, T b)",
      // "{",
      // "  if (b == 0)",
      // "    return a;",
      // "  else",
      // "    return gcd(b, a % b);",
      // "}",
      // "//calculate LCM of a and b",
      // "template <typename T>",
      // "inline T lcm(T a, T b) { return (a * b) / gcd(a, b); }"
      "lcm(a,b) // C++17以降はこれを使う"
    ],
    "scope": "cpp"
  },
  "extgcd": {
    "description": "extended Euclidean algorithm",
    "prefix": "extgcd",
    "body": [
      "/* 拡張ユークリッドの互除法の実装例",
      " 拡張ユークリッドの互除法とは、整数の組 (a,b) を入力として与えたときに以下の手順によってax+by=±gcd(a,b) となる整数の組 (x,y) を O(logmin(∣a∣,∣b∣)) で計算するアルゴリズムです。(ここで整数の組 x,y は max(∣x∣,∣y∣)≤max(∣a∣,∣b∣) を満たす整数であることが保証されています。)",
      "  ref:https://atcoder.jp/contests/abc340/editorial/9250",
      "*/",
      "P extgcd(ll a, ll b) {",
      "  if (b == 0) return make_pair(1, 0);",
      "  ll x, y;",
      "  tie(y, x) = extgcd(b, a % b);",
      "  y -= a / b * x;",
      "  return make_pair(x, y);",
      "}"

    ]
  },
  "Sieve of eratosthenes": {
    "description": "Sieve of eratosthenes",
    "prefix": "Sieve of eratosthenes",
    "body": [
      "//Sieve of eratosthenes",
      "vector<bool> is_prime(N + 1, true);",
      "is_prime[0] = false;",
      "is_prime[1] = false;",
      "for (ll i = 2; i * i <= N; i++)",
      "{",
      "  if (!is_prime[i])",
      "    continue;",
      "  for (ll j = i * 2; j <= N; j += i)",
      "  {",
      "    is_prime[j] = false;",
      "  }",
      "}"
    ]
  },
  "mint": {
    "description": "mint",
    "prefix": "mint",
    "body": [
      //ref:https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#1-%E3%81%AA%E3%81%9C-998244353-%E3%81%A7%E5%89%B2%E3%82%8B%E3%81%AE%E3%81%8B
      "// modint: mod 計算を int を扱うように扱える構造体",
      "template<ll MOD> struct Fp {",
      "  ll val;",
      "  constexpr Fp(ll v = 0) noexcept : val(v % MOD) {",
      "      if (val < 0) val += MOD;",
      "  }",
      "  constexpr ll getmod() { return MOD; }",
      "  constexpr Fp operator - () const noexcept {",
      "      return val ? MOD - val : 0;",
      "  }",
      "  constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }",
      "  constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }",
      "  constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }",
      "  constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }",
      "  constexpr Fp& operator += (const Fp& r) noexcept {",
      "      val += r.val;",
      "      if (val >= MOD) val -= MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator -= (const Fp& r) noexcept {",
      "      val -= r.val;",
      "      if (val < 0) val += MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator *= (const Fp& r) noexcept {",
      "      val = val * r.val % MOD;",
      "      return *this;",
      "  }",
      "  constexpr Fp& operator /= (const Fp& r) noexcept {",
      "      ll a = r.val, b = MOD, u = 1, v = 0;",
      "      while (b) {",
      "          ll t = a / b;",
      "          a -= t * b; swap(a, b);",
      "          u -= t * v; swap(u, v);",
      "      }",
      "      val = val * u % MOD;",
      "      if (val < 0) val += MOD;",
      "      return *this;",
      "  }",
      "  constexpr bool operator == (const Fp& r) const noexcept {",
      "      return this->val == r.val;",
      "  }",
      "  constexpr bool operator != (const Fp& r) const noexcept {",
      "      return this->val != r.val;",
      "  }",
      "  friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept",
      "  {",
      "    ll t;",
      "    is >> t;",
      "    x = Fp<MOD>(t);",
      "    return is;",
      "  }",
      "  friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {",
      "      return os << x.val;",
      "  }",
      "  friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, ll n) noexcept {",
      "      if (n == 0) return 1;",
      "      auto t = modpow(a, n / 2);",
      "      t = t * t;",
      "      if (n & 1) t = t * a;",
      "      return t;",
      "  }",
      "};",
      "",
      "",
      "const ll MOD = ${1|998244353,1000000007|};",
      "using mint = Fp<MOD>;",
    ]
  },
  "isPrime": {
    "prefix": "isPrime",
    "description": "is Prime",
    "body": [
      "bool isPrime(ll x){",
      "ll i;",
      "  if(x < 2) return 0;",
      "  else if(x == 2) return 1;",
      "  if(x%2 == 0) return 0;",
      "  for( i = 3; i * i <= x; i += 2) if(x%i == 0) return 0;",
      "  return 1;",
      "}"
    ]
  },
  "primeFactorization": {
    "prefix": "primeFactorization",
    "description": "prime Factorization",
    "body": [
      "vector<pair<ll, ll>> primeFactorization(ll n){",
      "  vector<pair<ll, ll>> res;",
      "  for(ll i = 2; i * i <= n; i++){",
      "    if(n % i != 0) continue;",
      "    res.push_back({i, 0});",
      "    while(n % i == 0){",
      "      n /= i;",
      "      res.back().second++;",
      "    }",
      "  }",
      "  if(n != 1) res.push_back({n, 1});",
      "  return res;",
      "}"
    ]
  },
  "digitsum": {
    "prefix": "digitsum",
    "description": "sum of digits",
    "body": [
      "ll digsum(ll n) {",
      "  ll res = 0;",
      "  while(n > 0) {",
      "      res += n % 10;",
      "      n /= 10;",
      "  }",
      "  return res;",
      "}"
    ]
  },
  "digits": {
    "prefix": "digits",
    "description": "digits",
    "body": [
      "ll digits(ll n) {",
      "  ll res = 0;",
      "  while(n > 0) {",
      "      res++;",
      "      n /= 10;",
      "  }",
      "  return res;",
      "}"
    ]
  },
  "enumDiv": {
    "prefix": "enumDiv",
    "description": "enum of divisors",
    "body": [
      "vector<ll> enum_div(ll n){",
      "  vector<ll> ret;",
      "  for(ll i = 1 ; i * i <= n ; ++i){",
      "    if(n%i == 0){",
      "      ret.push_back(i);",
      "      if(i != 1 && i * i != n){",
      "        ret.push_back(n/i);",
      "      }",

      "    }",
      "  }",
      "  return ret;",
      "}"
    ]
  }
}