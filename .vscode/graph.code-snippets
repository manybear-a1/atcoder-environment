{
  "input-graph-list": {
    "description": "load graph from input",
    "prefix": "ll N, M graph-list",
    "body": [
      "ll N, M;",
      "cin >> N >> M;",
      "vc<vc<ll>> G(N);",
      "//木ならN-1本の辺がある",
      "rep(i, M /* N - 1 */){",
      "  ll a, b;",
      "  cin >> a >> b;",
      "  //convert 1-indexed to 0-indexed",
      "  a--;",
      "  b--;",
      "  assert(a >= 0);",
      "  assert(b >= 0);",
      "  G[a].push_back(b);",
      "  G[b].push_back(a);",
      "}"
    ],
    "scope": "cpp"
  },
  "input-graph-matrix": {
    "description": "load graph from input",
    "prefix": "ll N, M graph-matrix",
    "body": [
      "ll N, M;",
      "cin >> N >> M;",
      "//G[u][v]:uからvへの辺のコスト",
      "vc<vc<ll>> G(N, vector<ll>(N, -1));",
      "//木ならN-1本の辺がある",
      "rep(i, M/* N - 1 */)",
      "{",
      "  ll a, b, c;",
      "  cin >> a >> b >> c;",
      "  //convert 1-indexed to 0-indexed",
      "  a--;",
      "  b--;",
      "  assert(a >= 0);",
      "  assert(b >= 0);",
      "  G[a][b] = c;",
      "  G[b][a] = c;",
      "}"
    ],
    "scope": "cpp"
  },

  "dijkstra": {
    "description": "dijkstra",
    "prefix": "dijkstra",
    //link:https://algo-logic.info/dijkstra/
    "body": [
      "struct Edge {",
      "  ll to;",
      "  ll cost;",
      "};",
      "using Graph = vector<vector<Edge>>;",
      "using P = pair<ll, ll>;",
      "//const ll INF = 1LL << 60;",
      "/* dijkstra(G,s,dis,prev)",
      "入力：グラフ G, 開始点 s, 距離を格納する dis, 最短経路の前の点を記録するprev",
      "計算量：O(|E|log|V|)",
      "副作用：dis, prevが書き換えられる",
      "使用法",
      "```",
      "//初期化は自動でされる",
      "vector<ll> dis, prev;",
      "dijkstra(G, r, dis, prev);",
      "```",
      "*/",
      "void dijkstra(const Graph &G, ll s, vector<ll> &dis, vector<ll> &prev) {",
      "  ll N = G.size();",
      "  dis.resize(N, INF);",
      "  prev.resize(N, -1); // 初期化",
      "  priority_queue<P, vector<P>, greater<P>> pq; ",
      "  dis[s] = 0;",
      "  pq.emplace(dis[s], s);",
      "  while (!pq.empty()) {",
      "    P p = pq.top();",
      "    pq.pop();",
      "    ll v = p.second;",
      "    if (dis[v] < p.first) {",
      "      continue;",
      "    }",
      "    for (auto &e : G[v]) {",
      "      if (dis[e.to] > dis[v] + e.cost) {",
      "        dis[e.to] = dis[v] + e.cost;",
      "        prev[e.to] = v; // 頂点 v を通って e.to にたどり着いた",
      "        pq.emplace(dis[e.to], e.to);",
      "      }",
      "    }",
      "  }",
      "}",
      "/* get_path(prev, t)",
      "入力：dijkstra で得た prev, ゴール t",
      "出力： t への最短路のパス",
      "*/",
      "vector<ll> get_path(const vector<ll> &prev, ll t) {",
      "  vector<ll> path;",
      "  for (ll cur = t; cur != -1; cur = prev[cur]) {",
      "    path.push_back(cur);",
      "  }",
      "  reverse(path.begin(), path.end()); // 逆順なのでひっくり返す",
      "  return path;",
      "}"
    ]
  },
  "bellmanfold": {
    "description": "bellmanfold",
    "prefix": "bellmanfold",
    //ref:https://algo-logic.info/bellman-ford/
    "body": [
      "struct Edge {",
      "  ll from;",
      "  ll to;",
      "  ll cost;",
      "};",
      "using Edges = vector<Edge>;",
      "//const ll INF = 1LL << 60;",
      "/* bellman_ford(Es,s,t,dis)",
      "  入力: 全ての辺Es, 頂点数V, 開始点 s, 最短経路を記録するdis",
      "  出力: 負の閉路が存在するなら ture",
      "  計算量：O(|E||V|)",
      "  副作用：dis が書き換えられる",
      "*/",
      "bool bellman_ford(const Edges &Es, ll V, ll s, vector<ll> &dis) {",
      "  dis.resize(V, INF);",
      "  dis[s] = 0;",
      "  ll cnt = 0;",
      "  while (cnt < V) {",
      "    bool end = true;",
      "    for (auto e : Es) {",
      "        if (dis[e.from] != INF && dis[e.from] + e.cost < dis[e.to]) {",
      "        dis[e.to] = dis[e.from] + e.cost;",
      "        end = false;",
      "      }",
      "    }",
      "    if (end) break;",
      "    cnt++;",
      "  }",
      "  return (cnt == V);",
      "}"
    ]
  },
  "warshall-floyd": {
    "description": "warshall-floyd",
    "prefix": "warshall-floyd",
    //ref:https://algo-logic.info/warshall-floyd/
    "body": [
      "//const ll INF = 1LL << 30;",
      "/* warshall_floyd(dist,prev)",
      "    入力：初期化した dist(隣接行列表現,存在しない辺はINF), prev(全要素について、prev[i][j] = i;)",
      "    計算量：O(|V|^3)",
      "    副作用：dis[i][j]にiからjへの最短路のコストを格納、prev[i][j]にiからjへの最短路でのjの1つ前の点を格納",
      "使用例：",
      "```",
      "ll N, M;",
      "cin >> N >> M;",
      "// G[u][v]:uからvへの辺のコスト",
      "vector<vector<ll>> G(N, vector<ll>(N, INF));",
      "rep(i, M)",
      "{",
      "  ll a, b, c;",
      "  cin >> a >> b >> c;",
      "  // convert 1-indexed to 0-indexed",
      "  a--;",
      "  b--;",
      "  assert(a >= 0);",
      "  assert(b >= 0);",
      "  G[a][b] = c;",
      "  //無向グラフ",
      "  G[b][a] = c;",
      "}",
      "rep(i, N)",
      "{",
      "  G[i][i] = 0;",
      "}",
      "vector<vector<ll>> prev(N);",
      "rep(i, N)",
      "{",
      "  prev[i].assign(N, i);",
      "}",
      "warshall_floyd(G, prev);",
      "```",
      "*/",
      "void warshall_floyd(vector<vector<ll>> &dist, vector<vector<ll>> &prev)",
      "{",
      "  ll V = dist.size();",
      "  for (ll k = 0; k < V; k++)",
      "  {",
      "    for (ll i = 0; i < V; i++)",
      "    {",
      "      for (ll j = 0; j < V; j++)",
      "      {",
      "        if (dist[i][k] == INF || dist[k][j] == INF)",
      "          continue;",
      "        if (dist[i][k] + dist[k][j] < dist[i][j])",
      "        {",
      "          dist[i][j] = dist[i][k] + dist[k][j];",
      "          prev[i][j] = prev[k][j];",
      "        }",
      "      }",
      "    }",
      "  }",
      "}",
      "/* get_path(prev, s, t)",
      "    入力：warshall_floyd で得た prev, スタート s, ゴール t",
      "    出力：s から t への最短路のパス",
      "*/",
      "vector<ll> get_path(const vector<vector<ll>> &prev, ll s, ll t)",
      "{",
      "  vector<ll> path;",
      "  for (ll cur = t; cur != s; cur = prev[s][cur])",
      "  {",
      "    path.push_back(cur);",
      "  }",
      "  path.push_back(s);",
      "  reverse(path.begin(), path.end());",
      "  return path;",
      "}",
      "/* is_negative(dist)",
      "    入力：warshall_floyd で得た dist",
      "    出力：負の有向路を含むかどうか",
      "*/",
      "bool is_negative(const vector<vector<ll>> &dist)",
      "{",
      "  ll V = dist.size();",
      "  for (ll i = 0; i < V; i++)",
      "  {",
      "    if (dist[i][i] < 0)",
      "    {",
      "      return true;",
      "    }",
      "  }",
      "  return false;",
      "}",
      "/*",
      "  現在のグラフに辺を追加する。削除はできない。",
      "  計算量O(V^2)",
      "  メモ：辺の削除をしたいときはクエリを逆から見て追加動作に変換すればうまくいくかも。",
      "*/",
      "void add_edge(vector<vector<ll>> &g, ll s, ll t, ll cost)",
      "{",
      "  g[s][t] = g[t][s] = min(g[s][t], cost);",
      "  for(ll k : {s, t}) {",
      "    for(ll i = 0; i < g.size(); i++) {",
      "      for(ll j = 0; j < g.size(); j++) {",
      "        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);",
      "      }",
      "    }",
      "  }",
      "}"
    ]
  },
  "Cycle Detection": {
    "description": "Cycle Detection",
    "prefix": "Cycle Detection",
    //ref:https://drken1215.hatenablog.com/entry/2023/05/20/200517#chap3
    "body": [
      "// 辺を表す構造体",
      "template<class T> struct Edge {",
      "  ll from, to;",
      "  T val;",
      "  Edge(ll f = -1, ll t = -1, T v = -1) : from(f), to(t), val(v) {}",
      "};",
      "",
      "// グラフを表す型",
      "template<class T> using Graph = vector<vector<Edge<T>>>;",
      "",
      "/* サイクル検出ソルバー",
      "使い方",
      "```",
      "ll main() {",
      "  // 有向グラフの受け取り",
      "  ll N, M;",
      "  cin >> N >> M;",
      "  Graph<ll> G(N);",
      "  for (ll i = 0; i < M; ++i) {",
      "      ll u, v;",
      "      cin >> u >> v;",
      "      G[u].push_back(Edge(u, v, i));",
      "  }",
      "  ",
      "  // cycle detection",
      "  CycleDetection<ll> cd(G);",
      "  const vector<Edge<ll>> &res = cd.detect(false);",
      "  ",
      "  // 出力",
      "  if (res.empty()) cout << -1 << endl;",
      "  else {",
      "      cout << res.size() << endl;",
      "      for (const Edge<ll> &e : res) {",
      "          cout << e.val << endl;",
      "      }",
      "  }",
      "}",
      "```",
      "*/",
      "template<class T> struct CycleDetection {",
      "  // 入力されたグラフ",
      "  Graph<T> G;",
      "  ",
      "  // 探索の様子",
      "  vector<bool> seen, finished;",
      "  vector<Edge<T>> history;",
      "  ",
      "  // コンストラクタ",
      "  CycleDetection() { }",
      "  CycleDetection(const Graph<T> &graph) { init(graph); }",
      "  void init(const Graph<T> &graph) {",
      "      G = graph;",
      "      seen.assign(G.size(), false);",
      "      finished.assign(G.size(), false);",
      "  }",
      "  ",
      "  // サイクル検出",
      "  // return the vertex where cycle is detected",
      "  ll dfs(ll v, const Edge<T> &e, bool is_prohibit_reverse = true) {",
      "      seen[v] = true;    // 行きがけ時に true になる",
      "      history.push_back(e);    // 履歴を残す",
      "      for (const Edge<T> &e2 : G[v]) {",
      "          // 逆流を禁止する場合は逆流を禁止する",
      "          if (is_prohibit_reverse && e2.to == e.from) continue;",
      "          ",
      "          // 頂点 v2 がすでに探索済みの場合はスキップ",
      "          if (finished[e2.to]) continue;",
      "",
      "          // サイクルが検出された",
      "          if (seen[e2.to] && !finished[e2.to]) {",
      "              history.push_back(e2);",
      "              return e2.to;",
      "          }",
      "",
      "          // 頂点 v2 を再帰的に探索する",
      "          ll pos = dfs(e2.to, e2, is_prohibit_reverse);",
      "          if (pos != -1) return pos;",
      "      }",
      "      finished[v] = true;    // 帰りがけ時に true になる",
      "      history.pop_back();    // 探索が完全に終了した頂点 (赤色) は履歴から除去する",
      "      return -1;",
      "  }",
      "  ",
      "  // 履歴からサイクルのみを抽出する関数 (pos：サイクルを検出した頂点)",
      "  vector<Edge<T>> reconstruct(ll pos) {",
      "      vector<Edge<T>> cycle;",
      "      ",
      "      // 履歴を遡ってサイクルを形作る",
      "      while (!history.empty()) {",
      "          const Edge<T> &e = history.back();",
      "          cycle.push_back(e);",
      "          history.pop_back();",
      "          if (e.from == pos) break;",
      "      }",
      "      ",
      "      // サイクルの向きを正順にする",
      "      reverse(cycle.begin(), cycle.end());",
      "      return cycle;",
      "  }",
      "  ",
      "  // サイクルを返す関数 (is_prohibit_reverse は逆流を許さないかどうか)",
      "  vector<Edge<T>> detect(bool is_prohibit_reverse = true) {",
      "      ll pos = -1;",
      "      for (ll v = 0; v < (ll)G.size() && pos == -1; ++v) {",
      "          if (seen[v]) continue;",
      "          history.clear();",
      "          pos = dfs(v, Edge<T>(), is_prohibit_reverse);",
      "          if (pos != -1) return reconstruct(pos);",
      "      }",
      "      return vector<Edge<T>>();",
      "  }",
      "};",
      "",
    ]
  }
}