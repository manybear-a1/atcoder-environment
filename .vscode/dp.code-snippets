{
  "range-dp": {
    "description": "templete of range-dp",
    "prefix": "dp by range",
    "body": [
      "//閉区間用",
      "vector<vector<ll>> dp;",
      "vc<ll> A;",
      "ll N;",
      "ll rec(${1:ll l, ll r}) {",
      "  if (dp[l][r] != -1)",
      "    return dp[l][r];",
      "  if (l == r)",
      "  {",
      "    dp[l][r] = 0;",
      "    return dp[l][r];",
      "  }",
      "}",
      "// cin >> N;",
      "// A.resize(N);",
      "// cin >> A;",
      "// dp.resize(N, vc<ll>(N, -1));"
    ]
  },
  "bit-DP": {
    "description": "bit DP",
    "prefix": "dp by subgroups",
    "body": [
      "//bit DP",
      "vector<vector<ll>> dp(1 << N, vector<ll>(N, INF));",
      "dp[0][0] = 0;",
      "rep(i, 1 << N)",
      "{",
      "  rep(j, N)",
      "  {",
      "    if (dp[i][j] == INF)",
      "      continue;",
      "    rep(k, N)",
      "    {",
      "      // 隣接行列表現です。",
      "      if (G[j][k] == INF)",
      "        continue;",
      "      if (i & (1 << k))",
      "        continue;",
      "      chmin(dp[i | (1 << k)][k], dp[i][j] + G[j][k]);",
      "    }",
      "  }",
      "}",
      "ll res = LLONG_MAX;",
      "chmin(res, dp[(1 << N) - 1][0]);",
      "if (res == LLONG_MAX)",
      "  cout << -1 << endl;",
      "else",
      "  cout << res << endl;"
    ],
    "scope": "cpp"
  },
  "LIS": {
    "description": "LIS",
    "prefix": "dp-LIS",
    "body": [
      "//LIS",
      "vector<ll> dp(N, LLONG_MAX);",
      "rep(i, N)",
      "{",
      "  *lower_bound(all(dp), A[i]) = A[i];",
      "}",
      "cout << lower_bound(all(dp), LLONG_MAX) - dp.begin() << endl;"
    ],
  },
  "doubling": {
    "prefix": "doubling",
    "description": "doubling",
    //ref:https://algo-logic.info/abc167d/
    "body": [
      "ll N, K;",
      "cin >> N >> K;",
      "vector<int> A(N);",
      "for (int i = 0; i < N; i++) {",
      "    cin >> A.at(i);",
      "    A[i]--;  // 0-indexed に変更",
      "}",
      "int logK = 1;",
      "while ((1LL << logK) <= K) logK++;",
      "// doubling[k][i] : i番目から 2^k 回移動した場所",
      "vector<vector<int> > doubling(logK, vector<int>(N));",
      "for (int i = 0; i < N; i++) {",
      "    doubling[0][i] = A[i];",
      "}",
      "// 前処理 doubling の計算",
      "for (int k = 0; k < logK - 1; k++) {",
      "    for (int i = 0; i < N; i++) {",
      "        doubling[k + 1][i] = doubling[k][doubling[k][i]];",
      "    }",
      "}",
      "int now = 0;",
      "for (int k = 0; K > 0; k++) {",
      "    if (K & 1) now = doubling[k][now];",
      "    K = K >> 1;",
      "}",
      "cout << now + 1 << endl;"
    ]
  },
  "tree-dp": {
    "prefix": "dp on tree",
    "description": "dp on tree",
    "body": [
      "// ref:https://algo-logic.info/tree-dp/",
      "// vを根とした時の根からの最大距離を求める",
      "struct DP {  // DP の型",
      "  long long dp;",
      "  DP(long long dp_ = 0) : dp(dp_) {}",
      "};",
      "struct Edge {",
      "  int to;",
      "};",
      "vc<vc<Edge>> G;",
      "vc<DP> dp;",
      "DP merge(DP dp_cum, DP d){  // 1.の二項演算を表す",
      "    return max(dp_cum.dp, d.dp);",
      "};",
      "DP add_root(DP d){  // 2.を表す。まとめたDPを用いて、新たな部分木のDPを計算する",
      "    return DP(d.dp + 1);",
      "};",
      "void dfs(int v, int p = -1) {  // 頂点v, 親p",
      "    int deg = G[v].size();     // 頂点vの次数",
      "    if (deg == 1) {            // 末端にいる時",
      "        dp[v] = 0;",
      "        return;",
      "    }",
      "    DP dp_cum = DP();",
      "    for (int i = 0; i < deg; i++) {",
      "        int u = G[v][i].to;          // u: vの子",
      "        if (u == p) continue;        // 親なら探索しない",
      "        dfs(u, v);                   // dp[u] の計算",
      "        dp_cum = merge(dp_cum, dp[u]);  // 1.の二項演算",
      "    }",
      "    dp[v] = add_root(dp_cum);  // 2.の計算",
      "}",
    ]
  },
  "tree-dp on each node": {
    "prefix": "dp on tree on each node",
    "description": "dp on tree on each node",
    "body": [
      "// ref:https://algo-logic.info/tree-dp/",
      "// 仮実装先:https://atcoder.jp/contests/abc220/tasks/abc220_f",
      "/* Rerooting: 全方位木 DP",
      "",
      "    計算量: O(N)",
      "*/",
      "struct Rerooting",
      "{",
      "  struct DP",
      "  { // DP の型",
      "    // dp: 頂点を根とした時の答え",
      "    ll dp;",
      "    // vertex_cnt: 部分木の頂点数(-1すると辺数)",
      "    ll vertex_cnt = 0;",
      "    //辺に重みが付いた時は未実装 ",
      "    //https://atcoder.jp/contests/abc160/submissions/11405183",
      "    DP(ll dp_) : dp(dp_) {}",
      "    DP() : dp(0) {}",
      "    DP(ll dp_, ll vertex_cnt_) : dp(dp_), vertex_cnt(vertex_cnt_) {}",
      "  };",
      "  const DP identity = DP(0); // 単位元(末端の値は add_root(identity) になるので注意)",
      "  //部分木の DP を合成するための二項演算",
      "  function<DP(DP, DP)> merge = [](DP dp_cum, DP d) -> DP",
      "  {",
      "    return DP(dp_cum.dp + d.dp, dp_cum.vertex_cnt + d.vertex_cnt);",
      "  };",
      "  //mergeでまとめられたdpの値から新たな部分木の DP を計算する",
      "  function<DP(DP)> add_root = [](DP d) -> DP",
      "  {",
      "    return DP(d.dp + d.vertex_cnt, d.vertex_cnt + 1);",
      "  };",
      "  // グラフの定義",
      "  struct Edge",
      "  {",
      "    int to;",
      "  };",
      "  using Graph = vector<vector<Edge>>;",
      "  vector<vector<DP>> dp; // dp[v][i]: vから出るi番目の有向辺に対応する部分木のDP",
      "  vector<DP> ans;        // ans[v]: 頂点vを根とする木の答え",
      "  Graph G;",
      "  Rerooting(int N) : G(N)",
      "  {",
      "    dp.resize(N);",
      "    ans.assign(N, identity);",
      "  }",
      "  void add_edge(int a, int b)",
      "  {",
      "    G[a].push_back({b});",
      "  }",
      "  void build()",
      "  {",
      "    dfs(0);           // 普通に木DP",
      "    bfs(0, identity); // 残りの部分木に対応するDPを計算",
      "  }",
      "  DP dfs(int v, int p = -1)",
      "  { // 頂点v, 親p",
      "    DP dp_cum = identity;",
      "    int deg = G[v].size();",
      "    dp[v] = vector<DP>(deg, identity);",
      "    for (int i = 0; i < deg; i++)",
      "    {",
      "      int u = G[v][i].to;",
      "      if (u == p)",
      "        continue;",
      "      dp[v][i] = dfs(u, v);",
      "      dp_cum = merge(dp_cum, dp[v][i]);",
      "      // dp_cum = merge(dp_cum, DP(dp[v][i].dp + G[v][i].cost));",
      "    }",
      "    return add_root(dp_cum);",
      "  }",
      "  void bfs(int v, const DP &dp_p, int p = -1)",
      "  { // bfs だが、実装が楽なので中身は dfs になっている",
      "    int deg = G[v].size();",
      "    for (int i = 0; i < deg; i++)",
      "    { // 前のbfsで計算した有向辺に対応する部分木のDPを保存",
      "      if (G[v][i].to == p)",
      "        dp[v][i] = dp_p;",
      "    }",
      "    vector<DP> dp_l(deg + 1, identity), dp_r(deg + 1, identity); // 累積merge",
      "    for (int i = 0; i < deg; i++)",
      "    {",
      "      dp_l[i + 1] = merge(dp_l[i], dp[v][i]);",
      "      // dp_l[i + 1] = merge(dp_l[i], DP(dp[v][i].dp + G[v][i].cost));",
      "    }",
      "    for (int i = deg - 1; i >= 0; i--)",
      "    {",
      "      dp_r[i] = merge(dp_r[i + 1], dp[v][i]);",
      "      // dp_r[i] = merge(dp_r[i + 1], DP(dp[v][i].dp + G[v][i].cost));",
      "    }",
      "    ans[v] = add_root(dp_l[deg]); // 頂点 v の答え",
      "    for (int i = 0; i < deg; i++)",
      "    { // 一つ隣の頂点に対しても同様に計算",
      "      int u = G[v][i].to;",
      "      if (u == p)",
      "        continue;",
      "      bfs(u, add_root(merge(dp_l[i], dp_r[i + 1])), v);",
      "    }",
      "  }",
      "};",
    ]
  }
}