{
  "square root decomposition": {
    "prefix": "square root decomposition",
    "body": [
      "// ref:https://tombo314.hatenablog.com/entry/2024/06/09/194217",
      "// ref:https://sigma1113.hatenablog.com/entry/2020/12/15/225256",
      "vector<ll> A(N);",
      "ll b_size = sqrt(N)+1;",
      "vector<ll> sum(b_size);",
      "ll Q;",
      "cin >> Q;",
      "rep(i,Q)",
      "ll l, r;",
      "cin >> l >> r;",
      "l--; r--;",
      "",
      "// 同じバケット内",
      "if (l/b_size==r/b_size){",
      "    ll s = 0;",
      "    // 愚直に足す",
      "rep(i, l, r){",
      "        s += A[i];",
      "    }",
      "    ans.emplace_back(s);",
      "} else {",
      "    // バケットを複数またぐとき",
      "    // 左端",
      "ll l_sum = 0;",
      "    rep(i, l, l/b_size*b_size+b_size){",
      "        l_sum += A[i];",
      "    }",
      "",
      "    // 右端",
      "ll r_sum = 0;",
      "    rep(i, r/b_size*b_size, r){",
      "        r_sum += A[i];",
      "    }",
      "    ll mid_sum = 0;",
      "",
      "    // 間にある各バケット",
      "rep(i, 0, b_size){",
      "        if (l<i*b_size && (i+1)*b_size<=r){",
      "            mid_sum += sum[i];",
      "        }",
      "    }",
      "    ans.emplace_back(l_sum+mid_sum+r_sum);",
      "}"
    ]
  },
  "Mo's algorithm": {
    "prefix": "Mo's algorithm",
    "body": [
      "/*",
      "from:https://ei1333.hateblo.jp/entry/2017/09/11/211011",
      "sample:https://atcoder.jp/contests/abc242/tasks/abc242_g",
      "```cpp",
      "  ll N;",
      "  cin >> N;",
      "  vc<ll> A(N);",
      "  cin >> A;",
      "  int Q;",
      "  cin >> Q;",
      "  Mo mo(N);",
      "  for (int i = 0; i < Q; i++)",
      "  {",
      "    int a, b;",
      "    cin >> a >> b;",
      "    mo.add(a - 1, b);",
      "  }",
      "  vector<int> cnt(N), ans(Q);",
      "  int sum = 0;",
      "  auto add = [&](int i)",
      "  {",
      "    if (cnt[A[i]] % 2 == 1)",
      "      ++sum;",
      "    cnt[A[i]]++;",
      "  };",
      "  auto erase = [&](int i)",
      "  {",
      "    if (cnt[A[i]] % 2 == 0)",
      "      --sum;",
      "    cnt[A[i]]--;",
      "  };",
      "  auto out = [&](int q)",
      "  {",
      "    ans[q] = sum;",
      "  };",
      "  mo.build(add, erase, out);",
      "  for (auto &p : ans)",
      "    cout << p << \"\\n\";",
      "  return 0;",
      "```",
      "*/",
      "struct Mo",
      "{",
      "  int n;",
      "  vector<pair<int, int>> lr;",
      "",
      "  explicit Mo(int n_) : n(n_) {}",
      "",
      "  void add(int l, int r)",
      "  { /* [l, r) */",
      "    lr.emplace_back(l, r);",
      "  }",
      "",
      "  template <typename AL, typename AR, typename EL, typename ER, typename O>",
      "  void build(const AL &add_left, const AR &add_right, const EL &erase_left, const ER &erase_right, const O &out)",
      "  {",
      "    int q = (int)lr.size();",
      "    int bs = n / min<int>(n, sqrt(q));",
      "    vector<int> ord(q);",
      "    iota(begin(ord), end(ord), 0);",
      "    sort(begin(ord), end(ord), [&](int a, int b)",
      "         {",
      "      int ablock = lr[a].first / bs, bblock = lr[b].first / bs;",
      "      if(ablock != bblock) return ablock < bblock;",
      "      return (ablock & 1) ? lr[a].second > lr[b].second : lr[a].second < lr[b].second; });",
      "    int l = 0, r = 0;",
      "    for (auto idx : ord)",
      "    {",
      "      while (l > lr[idx].first)",
      "        add_left(--l);",
      "      while (r < lr[idx].second)",
      "        add_right(r++);",
      "      while (l < lr[idx].first)",
      "        erase_left(l++);",
      "      while (r > lr[idx].second)",
      "        erase_right(--r);",
      "      out(idx);",
      "    }",
      "  }",
      "",
      "  template <typename A, typename E, typename O>",
      "  void build(const A &add, const E &erase, const O &out)",
      "  {",
      "    build(add, add, erase, erase, out);",
      "  }",
      "};",
    ]
  }
}