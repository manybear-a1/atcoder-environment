{
  "BFS-Grid": {
    "description": "BFS",
    "prefix": "BFS-Grid",
    "body": [
      "//BFS",
      "//first=y,second=x",
      "queue<pair<ll, ll>> q;",
      "//dist[y][x]",
      "ll hasnt_visited = INF;",
      "vector<vector<ll>> dist(H, vector<ll>(W, hasnt_visited));",
      "q.push({0,0});",
      "dist[0][0] = 0;",
      "int dx[] = {1, 0, -1, 0};",
      "int dy[] = {0, 1, 0, -1};",
      "while(!q.empty()){",
      "  auto [y, x] = q.front();",
      "  q.pop();",
      "  for(int i=0; i<4; i++){",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if (nx < 0 || nx >= W || ny < 0 || ny >= H)",
      "      continue;",
      "    if (S[ny][nx] == '#')",
      "      continue;",
      "    if (dist[ny][nx] == hasnt_visited || dist[ny][nx] > dist[y][x] + 1){",
      "      dist[ny][nx] = dist[y][x] + 1;",
      "      q.push({ny, nx});",
      "    }",
      "  }",
      "}"
    ],
  },
  "BFS-Graph": {
    "description": "BFS",
    "prefix": "BFS-Graph",
    "body": [
      "//ll N;",
      "//vector<vector<ll>> G(N);",
      "//BFS",
      "ll hasnt_visited = INF;",
      "vector<ll> dist(N, hasnt_visited);",
      "queue<ll> q;",
      "ll start = 0; // 開始頂点",
      "dist[start] = 0;",
      "q.push(start);",
      "while (!q.empty())",
      "{",
      "  ll u = q.front();",
      "  q.pop();",
      "  for (auto v : G[u])",
      "  {",
      "    if (dist[v] != hasnt_visited && dist[v] <= dist[u] + 1)",
      "      continue;",
      "    dist[v] = dist[u] + 1;",
      "    q.push(v);",
      "  }",
      "}",
    ],
  },
  "DFS-Grid-Stack": {
    "description": "DFS",
    "prefix": "DFS-Grid-Stack",
    "body": [
      "//DFS",
      "//first=y,second=x",
      "stack<pair<ll, ll>> q;",
      "//dist[y][x]",
      "vector<vector<ll>> dist(H, vector<ll>(W, -1));",
      "q.push({0,0});",
      "dist[y][x] = 0;",
      "int dx[] = {1, 0, -1, 0};",
      "int dy[] = {0, 1, 0, -1};",
      "while(!q.empty()){",
      "  auto [y, x] = q.front();",
      "  q.pop();",
      "  for(int i=0; i<4; i++){",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;",
      "    if(S[ny][nx] == '#') continue;",
      "    if(dist[ny][nx] != -1) continue;",
      "    dist[ny][nx] = dist[y][x] + 1;",
      "    q.push({ny, nx});",
      "  }",
      "}"
    ],
  },
  "DFS-Graph-Recursion": {
    "description": "DFS",
    "prefix": "DFS-Graph-Recursion",
    "body": [
      "//DFSテンプレ",
      "struct Edge",
      "{",
      "  ll to, idx;",
      "};",
      "// ll N, M;",
      "vc<vc<Edge>> G;",
      "G.resize(N);",
      "rep(i, M)",
      "{",
      "  G[U[i] - 1].push_back({V[i] - 1, i});",
      "  G[V[i] - 1].push_back({U[i] - 1, i});",
      "}",
      "// 頂点uの行きがけ順: dfs 関数に入った直後のuの順位",
      "vc<ll> first_order(N, -1);",
      "// 頂点uの帰りがけ順: dfs 関数から抜ける直前のuの順位(DAGの逆順)",
      "vc<ll> last_order(N, -1);",
      "vc<ll> depth(N, 0);",
      "ll first_ptr = 0, last_ptr = 0;",
      "// 再帰ラムダで DFS を定義(by o4-mini)",
      "// selfにはdfs自身を渡す",
      "auto dfs = [&](auto &&self, ll u, ll d) -> ll",
      "{",
      "  first_order[u] = first_ptr++;",
      "  depth[u] = d;",
      "  ll res = d;",
      "  for (auto &e : G[u])",
      "  {",
      "    ll v = e.to;",
      "    if (first_order[v] == -1)",
      "    {",
      "      chmax(res, self(self, v, d + 1));",
      "    }",
      "    else if (last_order[v] == -1)",
      "    {",
      "      // 閉路検出時の処理",
      "    }",
      "  }",
      "  last_order[u] = last_ptr++;",
      "  return res;",
      "};",
      "first_order.assign(N, -1);",
      "last_order.assign(N, -1);",
      "depth.assign(N, 0);",
      "first_ptr = 0;",
      "last_ptr = 0;",
      "// ルート 0 からスタート",
      "ll max_depth = dfs(dfs, 0, 0);"

    ],
  },
  "DFS-Grid-Recursion": {
    "description": "DFS",
    "prefix": "DFS-Grid-Recursion",
    "body": [
      "ll H, W;",
      "vector<string> S;",
      "int dx[4] = {1, 0, -1, 0};",
      "int dy[4] = {0, 1, 0, -1};",
      "vector<vector<ll>> depth;",
      "/*初期化を忘れずに。",
      "cin >> H >> W;",
      "S.resize(H);",
      "depth.resize(H, vector<ll>(W, -1));",
      "rep(i, H) cin >> S[i];",
      "DFS(0, 0, 0);",
      "*/",
      "void DFS(ll y, ll x, ll d)",
      "{",
      "  depth[y][x] = d;",
      "  rep(i, 4)",
      "  {",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if (nx < 0 || nx >= W || ny < 0 || ny >= H)",
      "      continue;",
      "    if (S[ny][nx] == '#')",
      "      continue;",
      "    if (depth[ny][nx]!= -1)",
      "    {",
      "      continue;",
      "    }",
      "    DFS(ny, nx, d + 1);",
      "  }",
      "  return;",
      "}",
    ],
  },
  "Complete Search with DFS and memoization": {
    "description": "Simple DFS (for complete search)",
    "prefix": "DFS(Complete Search and memoization)",
    "body": [
      "//dfsテンプレ",
      "// vc<ll> memo(N);",
      "auto dfs = [&](auto &&self, ll d) -> void",
      "{",
      "  if (d == N)",
      "  {",
      "    return;",
      "  }",
      "  rep(i, N)",
      "  {",
      "    self(self, d + 1);",
      "  }",
      "};",
      "dfs(dfs, 0);"
    ],
  },

}