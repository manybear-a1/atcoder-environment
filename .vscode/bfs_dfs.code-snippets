{
  "BFS-Grid": {
    "description": "BFS",
    "prefix": "BFS-Grid",
    "body": [
      "//BFS",
      "//first=y,second=x",
      "queue<pair<ll, ll>> q;",
      "//dist[y][x]",
      "vector<vector<ll>> dist(H, vector<ll>(W, INF));",
      "q.push({0,0});",
      "dist.at(0).at(0) = 0;",
      "int dx[] = {1, 0, -1, 0};",
      "int dy[] = {0, 1, 0, -1};",
      "while(!q.empty()){",
      "  auto [y, x] = q.front();",
      "  q.pop();",
      "  for(int i=0; i<4; i++){",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if (nx < 0 || nx >= W || ny < 0 || ny >= H)",
      "      continue;",
      "    if (dist[ny][nx] != INF)",
      "      continue;",
      "    if (S[ny][nx] == '#')",
      "      continue;",
      "    dist[ny][nx] = dist[y][x] + 1;",
      "    q.push({ny, nx});",
      "  }",
      "}"
    ],
  },
  "BFS-Graph": {
    "description": "BFS",
    "prefix": "BFS-Graph",
    "body": [
      "//ll N;",
      "//vector<vector<ll>> G;",
      "//BFS",
      "vector<ll> dist(N, -1);",
      "queue<ll> q;",
      "dist.at(0) = 0;",
      "q.push(0);",
      "while (!q.empty())",
      "{",
      "  ll u = q.front();",
      "  q.pop();",
      "  for (auto v : G.at(u))",
      "  {",
      "    if (dist.at(v) != -1 && dist.at(v) <= dist.at(u) + 1)",
      "      continue;",
      "    dist.at(v) = dist.at(u) + 1;",
      "    q.push(v);",
      "  }",
      "}",
    ],
  },
  "DFS-Grid-Stack": {
    "description": "DFS",
    "prefix": "DFS-Grid-Stack",
    "body": [
      "//DFS",
      "//first=y,second=x",
      "stack<pair<ll, ll>> q;",
      "//dist[y][x]",
      "vector<vector<ll>> dist(H, vector<ll>(W, -1));",
      "q.push({0,0});",
      "dist.at(0).at(0) = 0;",
      "int dx[] = {1, 0, -1, 0};",
      "int dy[] = {0, 1, 0, -1};",
      "while(!q.empty()){",
      "  auto [y, x] = q.front();",
      "  q.pop();",
      "  for(int i=0; i<4; i++){",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;",
      "    if(S[ny][nx] == '#') continue;",
      "    if(dist[ny][nx] != -1) continue;",
      "    dist[ny][nx] = dist[y][x] + 1;",
      "    q.push({ny, nx});",
      "  }",
      "}"
    ],
  },
  "DFS-Graph-Recursion": {
    "description": "DFS",
    "prefix": "DFS-Graph-Recursion",
    "body": [
      "ll N, M;",
      "vc<vc<ll>> G;",
      "//頂点uの行きがけ順: dfs 関数に入った直後のuの順位",
      "vc<ll> first_order;",
      "//頂点uの帰りがけ順: dfs 関数から抜ける直前のuの順位(DAGの逆順)",
      "vc<ll> last_order;",
      "vc<ll> depth;",
      "/*",
      "DFS",
      "使い方",
      "```",
      "//グラフの初期化を忘れずに。",
      "//N, M, G はグローバル変数である必要がある。",
      "G.resize(N);",
      "//グラフの入力を下で受け取る。",

      "// first_order, last_order, depth の初期化",
      "first_order.resize(N, -1);",
      "last_order.resize(N, -1);",
      "depth.resize(N, 0);",
      "ll first_ptr = 0;",
      "ll last_ptr = 0;",
      "DFS(0, 0, first_ptr, last_ptr);",
      "```",
      "*/",
      "ll DFS(ll u, ll d, ll &first_ptr, ll &last_ptr)",
      "{",
      "  first_order.at(u) = first_ptr++;",
      "  depth.at(u) = d;",
      "  ll res = d;",
      "  for (auto v : G[u])",
      "  {",
      "    if (first_order.at(v) == -1)",
      "    {",
      "      chmax(res, DFS(v, d + 1, first_ptr, last_ptr));",
      "    }",
      "    else",
      "    {",
      "      // すでに訪れた頂点の場合",
      "      ",
      "      if (last_order.at(v) == -1)",
      "      {",
      "        // 閉路がある場合",
      "        ",
      "        //cout << -1 << endl;",
      "        //exit(0);",
      "      }",
      "     }",
      "  }",
      "  last_order.at(u) = last_ptr++;",
      "  return res;",
      "}",

    ],
  },
  "DFS-Grid-Recursion": {
    "description": "DFS",
    "prefix": "DFS-Grid-Recursion",
    "body": [
      "ll H, W;",
      "vector<string> S;",
      "int dx[4] = {1, 0, -1, 0};",
      "int dy[4] = {0, 1, 0, -1};",
      "vector<vector<ll>> depth;",
      "/*初期化を忘れずに。",
      "cin >> H >> W;",
      "S.resize(H);",
      "depth.resize(H, vector<ll>(W, -1));",
      "rep(i, H) cin >> S[i];",
      "DFS(0, 0, 0);",
      "*/",
      "void DFS(ll y, ll x, ll d)",
      "{",
      "  depth.at(y).at(x) = d;",
      "  rep(i, 4)",
      "  {",
      "    ll nx = x + dx[i];",
      "    ll ny = y + dy[i];",
      "    if (nx < 0 || nx >= W || ny < 0 || ny >= H)",
      "      continue;",
      "    if (S[ny][nx] == '#')",
      "      continue;",
      "    if (depth.at(ny).at(nx) != -1)",
      "    {",
      "      continue;",
      "    }",
      "    DFS(ny, nx, d + 1);",
      "  }",
      "  return;",
      "}",
    ],
  },
  "Complete Search with DFS and memoization": {
    "description": "Complete Search with DFS and memoization",
    "prefix": "complete search",
    "body": [
      "// A template for complete search with memoization and dfs.",
      "map<int64_t, int64_t> memo;",
      "int64_t DFS(ll N)",
      "{",
      "  // memoization map to store results for each board state",
      "  if (memo.count(N))",
      "  {",
      "    return memo[N];",
      "  }",
      "  // base case: Don't forget to memoization the base case.",
      "  if (N == 0)",
      "  {",
      "    return memo[N] = 1;",
      "  }",
      "  int64_t result = 0; // initialize result. It is not recommended to initialize it with recursive calls. That would lead to make bugs.",
      "  // iterate through all possible valid answers.",
      "  rep(i, N)",
      "  {",
      "    result += DFS(N - 1);",
      "  }",
      "  // store the result in the memoization map",
      "",
      "  return memo[N] = result;",
      "}"
    ],
  },

}