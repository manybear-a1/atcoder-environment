{
  "input-tree": {
    "description": "load tree from input",
    "prefix": "ll N tree",
    //ref:https://algo-logic.info/tree-diameter/
    "body": [
      "ll N;",
      "cin >> N;",
      "vector<vector<ll>> G(N);",
      "rep(i, N - 1){",
      "  ll a, b;",
      "  cin >> a >> b;",
      "  //convert 1-indexed to 0-indexed",
      "  a--;",
      "  b--;",
      "  assert(a >= 0);",
      "  assert(b >= 0);",
      "  G[a].push_back(b);",
      "  G[b].push_back(a);",
      "}"
    ],
    "scope": "cpp"
  },
  "Eular-Tour": {
    "description": "Eular-Tour",
    "prefix": "Eular-Tour",
    //ref:https://qiita.com/Dunsparce/items/d3a832b71ac10becd33d
    "body": [
      "struct Edge",
      "{",
      "  ll to;",
      "};",
      "struct S_rmq",
      "{",
      "  ll value;",
      "  ll index;",
      "};",
      "S_rmq op_rmq(S_rmq a, S_rmq b)",
      "{",
      "  if (a.value < b.value)",
      "    return a;",
      "  else",
      "    return b;",
      "}",
      "S_rmq E_rmq() { return {(1LL << 60), -1LL}; }",
      "/*",
      "ref:https://qiita.com/Dunsparce/items/d3a832b71ac10becd33d",
      "使用例",
      "```",
      "#include <iostream>",
      "#include <vector>",
      "#include <atcoder/segtree>",
      "//aclを利用していることに気を付けてください。",
      "//ほかのコンテストサイトに提出する際は、aclのsegtreeをダウンロードするか、",
      "//自前のセグ木で書き換えてください。",
      "using namespace std;",
      "",
      "//LCA euler_tourのコードを貼ってください(割愛します)",
      "",
      "int main()",
      "{",
      "    int n; cin >> n;",
      "",
      "    euler_tour et(n);",
      "    //木なのでn-1本の辺があります",
      "    for(int i=0;i<n-1;i++){",
      "        int u,v; cin >> u >> v;",
      "        u--; v--; //0-indexedにしてください",
      "        et.add_edge(u,v);",
      "    }",
      "",
      "        //こちらの書き方もできます",
      "        //vector<vector<Edge>> g(n);",
      "        //for(int i=0;i<n-1;i++){",
      "          //  int u,v; cin >> u >> v;",
      "          //  u--; v--;",
      "          //  g[u].push_back({v});",
      "          //  g[v].push_back({u});",
      "        //}",
      "       // euler_tour et(n,g);",
      "",
      "    et.dfs(0); //これを忘れないで下さい(セグフォります)",
      "",
      "    cout << et.lca(2,3) << endl; //頂点2と頂点3のLCAを出力します。",
      "    cout << et.dist(2,3) << endl; //頂点2と頂点3の距離を出力します。",
      "}",
      "```",
      "*/",
      "struct euler_tour",
      "{",
      "  vector<ll> depth, visit;",
      "  vector<ll> discover, finishing;",
      "  vector<vector<Edge>> g;",
      "  ll n;",
      "  bool is_dirty = true;",
      "",
      "  atcoder::segtree<S_rmq, op_rmq, E_rmq> rmq;",
      "",
      "  euler_tour(ll n = 1, vector<vector<Edge>> g = vector<vector<Edge>>())",
      "  {",
      "    init(n, g);",
      "  }",
      "#pragma warning(suppress : 4458)",
      "  void init(ll n, vector<vector<Edge>> g)",
      "  {",
      "    this->n = n;",
      "    depth.clear();",
      "    visit.clear();",
      "    discover.assign(n, (1 << 30));",
      "    finishing.assign(n, -1);",
      "    this->g = g;",
      "    this->g.resize(n);",
      "  }",
      "  // 計算量:O(n)",
      "  // 注意事項",
      "  // 同様のことをEdgeの二次元配列を用意することで行うことができます。",
      "  void add_edge(ll u, ll v)",
      "  {",
      "    g[u].push_back({v});",
      "    g[v].push_back({u});",
      "  }",
      "  // 計算量:O(N)",
      "  // 注意事項",
      "  // たいていの場合root(根)は0としてしまって困ることはないと思います。また、辺を追加した後に必ず行ってください。initのようなものなので、忘れると範囲外アクセスを引き起こします。",
      "  void dfs(ll root)",
      "  {",
      "    Dfs(root, -1, 0);",
      "    for (ll i = 0; i < int(visit.size()); i++)",
      "    {",
      "      discover[visit[i]] = min(discover[visit[i]], i);",
      "      finishing[visit[i]] = max(finishing[visit[i]], i + 1);",
      "    }",
      "    vector<S_rmq> depth_v(int(depth.size()));",
      "    for (ll i = 0; i < int(depth.size()); i++)",
      "    {",
      "      depth_v[i] = {depth[i], visit[i]};",
      "    }",
      "",
      "    rmq = atcoder::segtree<S_rmq, op_rmq, E_rmq>(depth_v);",
      "    is_dirty = false;",
      "  }",
      "",
      "  // dfsの補助関数",
      "  // 外部から呼び出さないでください。",
      "  void Dfs(ll v, ll p, ll d)",
      "  {",
      "    visit.push_back(v);",
      "    depth.push_back(d);",
      "    for (Edge u : g[v])",
      "    {",
      "      if (u.to == p)",
      "        continue;",
      "      Dfs(u.to, v, d + 1);",
      "      visit.push_back(v);",
      "      depth.push_back(d);",
      "    }",
      "  }",
      "  void check()",
      "  {",
      "    if (is_dirty)",
      "    {",
      "      cout << \"dfsを行ってください\" << endl;",
      "      dfs(0);",
      "    }",
      "  }",
      "  // lowest common ancestor(最小共通祖先)",
      "  // 計算量:O(logN)",
      "  // uv間のlcaを求めます。",
      "  ll lca(ll u, ll v)",
      "  {",
      "    check();",
      "    return rmq.prod(min(discover[u], discover[v]), max(finishing[u], finishing[v])).index;",
      "  }",
      "",
      "  // 計算量:O(logN)",
      "  // uv間の距離を求めます。",
      "  ll dist(ll u, ll v)",
      "  {",
      "    check();",
      "    return depth[discover[u]] + depth[discover[v]] - 2 * depth[discover[lca(u, v)]];",
      "  }",
      "};",
    ]
  },
  "kruskal": {
    "prefix": "kruskal",
    "description": "kruskal",
    "body": [
      "/* UnionFind：素集合系管理の構造体(union by rank)",
      "    isSame(x, y): x と y が同じ集合にいるか。 計算量はならし O(α(n))",
      "    unite(x, y): x と y を同じ集合にする。計算量はならし O(α(n))",
      "*/",
      "struct UnionFind {  // The range of node number is u 0 v n-1",
      "  vector<ll> rank, parents;",
      "  UnionFind() {}",
      "  UnionFind(ll n) {  // make n trees.",
      "    rank.resize(n, 0);",
      "    aparents.resize(n, 0);",
      "    for (ll i = 0; i < n; i++) {",
      "      makeTree(i);",
      "    }",
      "  }",
      "  void makeTree(ll x) {",
      "    parents[x] = x;  // the parent of x is x",
      "    rank[x] = 0;",
      "  }",
      "  bool isSame(ll x, ll y) { return findRoot(x) == findRoot(y); }",
      "  void unite(ll x, ll y) {",
      "    x = findRoot(x);",
      "    y = findRoot(y);",
      "    if (rank[x] > rank[y]) {",
      "      parents[y] = x;",
      "    } else {",
      "      parents[x] = y;",
      "      if (rank[x] == rank[y]) {",
      "        rank[y]++;",
      "      }",
      "    }",
      "  }",
      "  ll findRoot(ll x) {",
      "    if (x != parents[x]) parents[x] = findRoot(parents[x]);",
      "    return parents[x];",
      "  }",
      "};",
      "// 辺の定義",
      "struct Edge {",
      "ll u;",
      "ll v;",
      "ll cost;",
      "};",
      "bool comp_e(const Edge &e1, const Edge &e2) { return e1.cost < e2.cost; } // 辺を直接比較するための関数",
      "/* Kruskal :クラスカル法で minimum spanning tree を求める構造体",
      "入力: 辺のvector, 頂点数V",
      "最小全域木の重みの総和: sum",
      "計算量: O(|E|log|V|)",
      "使い方",
      "```",
      "ll V, E;",
      "cin >> V >> E;",
      "vector<Edge> edges(E);",
      "rep(i, E){",
      "  ll s, t, w;",
      "  cin >> s >> t >> w;",
      "  Edge e = {s, t, w};",
      "  s--;",
      "  t--;",
      "  assert(s >= 0);",
      "  assert(t >= 0);",
      "  edges[i] = e;",
      "}",
      "Kruskal krs(edges, V);",
      "```",
      "*/",
      "struct Kruskal {",
      "UnionFind uft;",
      "ll sum;  // 最小全域木の重みの総和",
      "vector<Edge> edges;",
      "ll V;",
      "Kruskal(const vector<Edge> &edges_, ll V_) : edges(edges_), V(V_) { init(); }",
      "  void init() {",
      "    sort(edges.begin(), edges.end(), comp_e); // 辺の重みでソート",
      "    uft = UnionFind(V);",
      "    sum = 0;",
      "    for (auto e : edges) {",
      "      if (!uft.isSame(e.u, e.v)) { // 閉路にならなければ加える",
      "        uft.unite(e.u, e.v);",
      "        sum += e.cost;",
      "      }",
      "    }",
      "  }",
      "};"
    ]
  },
  "diameter": {
    "prefix": "diameter",
    "description": "diameter",
    "body": [
      "template <typename T>",
      "struct Edge {",
      " ll to;",
      "  T cost;",
      "};",
      "using Graph = vector<vector<Edge<ll>>>;  // cost の型を long long に指定",
      "/* tree_diamiter : dfs を用いて重み付き木 T の直径を求める",
      "  計算量: O(N)",
      "*/",
      "template <typename T>",
      "pair<T, ll> dfs(const Graph &G, ll u, ll par) {  // 最遠点間距離と最遠点を求める",
      "  pair<T, ll> ret = make_pair((T)0, u);",
      "  for (auto e : G[u]) {",
      "    if (e.to == par) continue;",
      "    auto next = dfs<T>(G, e.to, u);",
      "    next.first += e.cost;",
      "    ret = max(ret, next);",
      "  }",
      "  return ret;",
      "}",
      "template <typename T>",
      "T tree_diamiter(const Graph &G) {",
      "  pair<T, ll> p = dfs<T>(G, 0, -1);",
      "  pair<T, ll> q = dfs<T>(G, p.second, -1);",
      "  return q.first;",
      "}"
    ]
  },
  "Trie-tree": {
    "prefix": "Trie-tree",
    "description": "Trie-tree",
    "body": [
      "//https://algo-logic.info/trie-tree/",
      "/* Trie 木： 文字の種類(char_size)、int型で0に対応する文字(base)",
      "    insert(word): 単語 word を Trie 木に挿入する",
      "    search(word): 単語 word が Trie 木にあるか判定する",
      "    start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
      "    count(): 挿入した単語の数を返す",
      "    size(): Trie 木の頂点数を返す",
      "    計算量：insert, search ともに O(M)（Mは単語の長さ）",
      "*/",
      "template <int char_size, int base>",
      "struct Trie {",
      "    struct Node {            // 頂点を表す構造体",
      "        vector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
      "        vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
      "        int c;               // base からの間隔をint型で表現したもの",
      "        int common;          // いくつの単語がこの頂点を共有しているか",
      "        Node(int c_) : c(c_), common(0) {",
      "            next.assign(char_size, -1);",
      "        }",
      "    };",
      "    vector<Node> nodes;  // trie 木本体",
      "    int root;",
      "    Trie() : root(0) {",
      "        nodes.push_back(Node(root));",
      "    }",
      "    // 単語の挿入",
      "    void insert(const string &word, int word_id) {",
      "        int node_id = 0;// root",
      "        for (int i = 0; i < (int)word.size(); i++) {",
      "            int c = (int)(word[i] - base);",
      "            int &next_id = nodes[node_id].next[c];",
      "            if (next_id == -1) {  // 次の頂点が存在しなければ追加",
      "                next_id = (int)nodes.size();",
      "                nodes.push_back(Node(c));",
      "            }",
      "            ++nodes[node_id].common;",
      "            node_id = next_id;",
      "        }",
      "        //leaf node",
      "        ++nodes[node_id].common;",
      "        nodes[node_id].accept.push_back(word_id);",
      "    }",
      "    void insert(const string &word) {",
      "        insert(word, nodes[0].common);",
      "    }",
      "    // 単語とprefixの検索",
      "    bool search(const string &word, bool prefix = false) {",
      "        int node_id = 0;",
      "        for (int i = 0; i < (int)word.size(); i++) {",
      "            int c = (int)(word[i] - base);",
      "            int &next_id = nodes[node_id].next[c];",
      "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
      "                return false;",
      "            }",
      "            node_id = next_id;",
      "        }",
      "        return (prefix) ? true : nodes[node_id].accept.size() > 0;",
      "    }",
      "    // prefix を持つ単語が存在するかの検索",
      "    bool start_with(const string &prefix) {",
      "        return search(prefix, true);",
      "    }",
      "    // 挿入した単語の数",
      "    int count() const {",
      "        return (nodes[0].common);",
      "    }",
      "    // Trie木のノード数",
      "    int size() const {",
      "        return ((int)nodes.size());",
      "    }",
      "};"
    ]
  }
}