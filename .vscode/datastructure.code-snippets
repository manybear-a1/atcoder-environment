{
  "Union Find": {
    "description": "Union Find(deprecated,AC Libraryのdsuを使ってください。",
    "prefix": "UnionFind",
    //ref:https://algo-logic.info/union-find-tree/
    "body": [
      "//AC Libraryのdsuを使ってください。",
      "/* UnionFind：素集合系管理の構造体(union by rank)",
      "    isSame(x, y): x と y が同じ集合にいるか。 計算量はならし O(α(n))",
      "    unite(x, y): x と y を同じ集合にする。計算量はならし O(α(n))",
      "*/",
      "struct UnionFind {  // The range of node number is u 0 v n-1",
      "  vector<int> size, parents;",
      "  UnionFind() {}",
      "  UnionFind(int n) {  // make n trees.",
      "    size.resize(n, 0);",
      "    parents.resize(n, 0);",
      "    for (int i = 0; i < n; i++) {",
      "      makeTree(i);",
      "    }",
      "  }",
      "  void makeTree(int x) {",
      "    parents[x] = x;  // the parent of x is x",
      "    size[x] = 1;",
      "  }",
      "  bool isSame(int x, int y) { return findRoot(x) == findRoot(y); }",
      "  void unite(int x, int y) {",
      "    x = findRoot(x);",
      "    y = findRoot(y);",
      "    if (size[x] > size[y]) {",
      "      parents[y] = x;",
      "      size[x] += size[y];",
      "    } else {",
      "      parents[x] = y;",
      "      size[y] += size[x];",
      "    }",
      "  }",
      "  int findRoot(int x) {",
      "    if (x != parents[x]) parents[x] = findRoot(parents[x]);",
      "    return parents[x];",
      "  }",
      "  int treeSize(int x) { return size[findRoot(x)]; }",
      "};",
    ]
  },
  "Store ranges in a set": {
    "description": "Store ranges in a set",
    "prefix": "range_set",
    "body": [
      "// https://atcoder.jp/contests/abc330/editorial/7754?lang=ja",
      "template <class T>",
      "struct range_set",
      "{",
      "private:",
      "  const T TINF = std::numeric_limits<T>::max() / 2;",
      "  T sum;",
      "  std::set<std::pair<T, T>> st;",
      "",
      "public:",
      "  range_set() : sum(0)",
      "  {",
      "    // initialize with empty set with sentinels",
      "    st.emplace(-TINF, -TINF);",
      "    st.emplace(TINF, TINF);",
      "  }",
      "  //[l, r) is covered?",
      "  bool covered(const T l, const T r)",
      "  {",
      "    assert(l <= r);",
      "    if (l == r)",
      "      return true;",
      "    // get the last section which is not greater than l (smaller or equal)",
      "    auto itr = prev(st.upper_bound({l, TINF}));",
      "    return itr->first <= l and r <= itr->second;",
      "  }",
      "  //[x, x + 1) is covered?",
      "  bool covered(const T x) { return covered(x, x + 1); }",
      "  // return section which covers[l, r)",
      "  // if not exists, return[-TINF, -TINF)",
      "  std::pair<T, T> covered_by(const T l, const T r)",
      "  {",
      "    assert(l <= r);",
      "    if (l == r)",
      "      return {-TINF, -TINF};",
      "    // get the last section which is not greater than l (smaller or equal)",
      "    auto itr = prev(st.upper_bound({l, TINF}));",
      "    if (itr->first <= l and r <= itr->second)",
      "      return *itr;",
      "    return {-TINF, -TINF};",
      "  }",
      "  // return section which covers[x, x + 1)",
      "  // if not exists, return[-TINF, -TINF)",
      "  std::pair<T, T> covered_by(const T x) { return covered_by(x, x + 1); }",
      "  // insert[l, r), and return increment of covered range",
      "  T insert(T l, T r)",
      "  {",
      "    assert(l <= r);",
      "    if (l == r)",
      "      return T(0);",
      "    // get the last section which is not greater than l (smaller or equal)",
      "    auto itr = prev(st.upper_bound({l, TINF}));",
      "    if (itr->first <= l and r <= itr->second)",
      "      return T(0);",
      "    T sum_erased = T(0);",
      "    // if the section has intersection with [l, r), we need to erase it (and concatenate at last)",
      "    if (itr->first <= l and l <= itr->second)",
      "    {",
      "      l = itr->first;",
      "      sum_erased += itr->second - itr->first;",
      "      itr = st.erase(itr);",
      "    }",
      "    else",
      "      itr = next(itr);",
      "    // erase sections which are completely covered by [l, r)",
      "    while (r > itr->second)",
      "    {",
      "      sum_erased += itr->second - itr->first;",
      "      itr = st.erase(itr);",
      "    }",
      "    // if the section has intersection with [l, r), we need to erase it (and concatenate at last)",
      "    if (itr->first <= r)",
      "    {",
      "      sum_erased += itr->second - itr->first;",
      "      r = itr->second;",
      "      st.erase(itr);",
      "    }",
      "    // insert the new section (concatenated)",
      "    st.emplace(l, r);",
      "    sum += r - l - sum_erased;",
      "    return r - l - sum_erased;",
      "  }",
      "  // insert[x, x + 1), and return increment of covered range",
      "  T insert(const T x) { return insert(x, x + 1); }",
      "  // erase [l, r), and return decrement of covered range",
      "  T erase(const T l, const T r)",
      "  {",
      "    assert(l <= r);",
      "    if (l == r)",
      "      return T(0);",
      "    // get the last section which is not greater than l (smaller or equal)",
      "    auto itr = prev(st.upper_bound({l, TINF}));",
      "    // if the section completely covers [l, r), we can simply split or erase it",
      "    if (itr->first <= l and r <= itr->second)",
      "    {",
      "      if (itr->first < l)",
      "        st.emplace(itr->first, l);",
      "      if (r < itr->second)",
      "        st.emplace(r, itr->second);",
      "      st.erase(itr);",
      "      sum -= r - l;",
      "      return r - l;",
      "    }",
      "    T ret = T(0);",
      "    // if the section such that itr.first <= l has intersection  with [l, r), we need to erase it",
      "    if (itr->first <= l and l < itr->second)",
      "    {",
      "      ret += itr->second - l;",
      "      if (itr->first < l)",
      "        st.emplace(itr->first, l);",
      "      itr = st.erase(itr);",
      "    }",
      "    else",
      "      itr = next(itr);",
      "    // erase sections which are completely covered by [l, r)",
      "    while (itr->second <= r)",
      "    {",
      "      ret += itr->second - itr->first;",
      "      itr = st.erase(itr);",
      "    }",
      "    // if the section has intersection with [l, r), we need to erase it",
      "    if (itr->first < r)",
      "    {",
      "      ret += r - itr->first;",
      "      st.emplace(r, itr->second);",
      "      st.erase(itr);",
      "    }",
      "    sum -= ret;",
      "    return ret;",
      "  }",
      "  // erase [x, x + 1), and return decrement of covered range",
      "  T erase(const T x) { return erase(x, x + 1); }",
      "  int size() const { return (int)st.size() - 2; }",
      "  // return mex of covered range",
      "  // i.e. the smallest integer not covered from x",
      "  T mex(const T x = 0) const",
      "  {",
      "    // get the last section which is not greater than x (smaller or equal)",
      "    auto itr = prev(st.upper_bound({x, TINF}));",
      "    if (itr->first <= x and x < itr->second)",
      "      return itr->second;",
      "    else",
      "      return x;",
      "  }",
      "  T sum_all() const { return sum; }",
      "  std::set<std::pair<T, T>> get() const",
      "  {",
      "    // copy",
      "    std::set<std::pair<T, T>> res;",
      "    for (auto &p : st)",
      "    {",
      "      if (std::abs(p.first) == TINF)",
      "        continue;",
      "      res.emplace(p.first, p.second);",
      "    }",
      "    return res;",
      "  }",
      "  void dump() const",
      "  {",
      "    std::cout << \"range_set:\";",
      "    for (auto &p : st)",
      "    {",
      "      if (std::abs(p.first) == TINF)",
      "        continue;",
      "      std::cout << \"[\" << p.first << \",\" << p.second << \"),\";",
      "    }",
      "    std::cout << '\\n';",
      "  }",
      "};",
    ]
  }
}